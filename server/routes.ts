import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { api } from "@shared/routes";
import { z } from "zod";
import passport from "passport";
import { Strategy as DiscordStrategy } from "passport-discord";
import session from "express-session";
import axios from "axios";
import * as cheerio from "cheerio";
import JSZip from "jszip";

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {

  // Session Setup
  app.use(session({
    secret: process.env.SESSION_SECRET || 'keyboard cat',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: process.env.NODE_ENV === 'production' }
  }));

  // Passport Setup
  app.use(passport.initialize());
  app.use(passport.session());

  passport.serializeUser((user: any, done) => {
    done(null, user.id);
  });

  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (err) {
      done(err, null);
    }
  });

  const clientID = process.env.DISCORD_CLIENT_ID;
  const clientSecret = process.env.DISCORD_CLIENT_SECRET;
  const callbackURL = `${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'http://0.0.0.0:5000'}/auth/discord/callback`;

  if (clientID && clientSecret) {
    passport.use(new DiscordStrategy({
      clientID,
      clientSecret,
      callbackURL,
      scope: ['identify']
    }, async (accessToken, refreshToken, profile, done) => {
      try {
        let user = await storage.getUserByDiscordId(profile.id);
        if (!user) {
          user = await storage.createUser({
            discordId: profile.id,
            username: profile.username,
            avatar: profile.avatar,
          });
        } else {
            // Update details on login
            user = await storage.updateUser(user.id, {
                username: profile.username,
                avatar: profile.avatar
            });
        }
        return done(null, user);
      } catch (err) {
        return done(err as Error, undefined);
      }
    }));
  } else {
    console.warn("Discord credentials not provided. Auth will fail.");
  }

  // Auth Routes
  app.get(api.auth.discord.path, passport.authenticate('discord'));

  app.get(api.auth.callback.path, 
    passport.authenticate('discord', { failureRedirect: '/' }),
    (req, res) => {
      res.redirect('/');
    }
  );

  app.post(api.auth.logout.path, (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.json({ message: "Logged out" });
    });
  });

  app.get(api.auth.me.path, (req, res) => {
    if (req.isAuthenticated()) {
      res.json(req.user);
    } else {
      res.json(null);
    }
  });

  // Steam Routes
  app.get(api.steam.depots.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.status(401).send("Unauthorized");
    const { appid } = req.params;
    
    try {
      const { data } = await axios.get(`https://steamdb.info/app/${appid}/depots/`, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });
      
      const $ = cheerio.load(data);
      const depots: { id: string, name: string }[] = [];
      
      // Basic scraping logic - dependent on SteamDB structure which might change
      // Looking for table rows with depot info
      $('.app-row').each((i, el) => {
          // This selector is a guess based on standard table structures, might need refinement
          // SteamDB usually has a table with class 'table-depots' or similar
      });
       // Fallback/Simpler selector try:
       $('tr').each((i, el) => {
           const id = $(el).find('td:nth-child(1)').text().trim();
           const name = $(el).find('td:nth-child(2)').text().trim();
           const type = $(el).find('td:nth-child(3)').text().trim();
           
           if (id && !isNaN(parseInt(id)) && (type.includes('depot') || type.includes('content'))) {
             depots.push({ id, name });
           }
       });

      res.json(depots);
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "Failed to fetch depots" });
    }
  });

  app.post(api.steam.generate.path, async (req, res) => {
    if (!req.isAuthenticated()) return res.status(401).send("Unauthorized");
    
    const { appId, depotId, manifestId } = req.body;
    
    // Generate Lua Content
    const manifestGid = manifestId || "8888888888888888888"; // Fake if not provided
    
    const luaContent = `
-- Generated by Steam Manifest Generator
appid = ${appId}
depots = {
    [${depotId}] = {
        ["manifest"] = "${manifestGid}",
        ["key"] = "0000000000000000000000000000000000000000000000000000000000000000",
        ["target"] = "default",
    },
}
`;

    // Generate Fake Manifest Content (minimal protobuf-like structure or just text for now as placeholder)
    // The user description implies a fake .manifest file.
    // A real manifest is binary VDF/Protobuf. A "fake" one might just be a placeholder 
    // or the Lua script handles the injection.
    // "Outputs two files: <appid>.lua and <appid>_<depotid>.manifest"
    const manifestContent = `Fake Manifest Content for ${appId} - ${depotId}`;

    const zip = new JSZip();
    zip.file(`${appId}.lua`, luaContent);
    zip.file(`${appId}_${depotId}.manifest`, manifestContent);
    
    const content = await zip.generateAsync({ type: "nodebuffer" });
    
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename=manifest_${appId}.zip`);
    res.send(content);
  });

  return httpServer;
}
